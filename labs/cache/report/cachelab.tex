% !TEX root = main.tex

\section{简介}

\subsection{实验目的}

\begin{itemize}[noitemsep]
    \item 理解高速缓存(Cache)的工作原理, 掌握常见的映射方式和替换策略.
    \item 学会针对Cache对程序代码进行优化.
\end{itemize}

\subsection{实验要求}

\begin{itemize}
  \item Part A: \\编写一个Cache模拟器 \verb|csim| , 支持任意参数的组相连映射(Set associative), 采用最近最少使用(Least recently used)替换策略, 功能应当与给定的参考程序 \verb|csim-ref| 一致.
  \item Part B: \\优化一个矩阵转置函数, 尽可能减少Cache misses, 提高Cache命中率. 考虑 $32 \times 32$, $ 64 \times 64$ 和 $ 61 \times 67$ 三种情形. 要求遵守给定的编程规则.
\end{itemize}

\subsection{实验环境}

本实验Part A在以下环境完成:
\begin{center}
    \small
    \begin{tabular}{ll}
      \toprule
      Machine & MacBook Pro 13" \\
      SoC & Apple M1, 基于ARM, 含8核CPU、8核GPU及16GB RAM \\
      OS & macOS Monterey 12.4 \\
      IDE & Visual Studio Code 1.68.1 \\
      Docker & Docker 20.10.13 \\
      Image & Ubuntu 22.04, amd64 \\
      Packages & GCC 11.2.0, Make 4.3, Python 2.7.18, Valgrind 3.18.1\\
      \bottomrule
    \end{tabular}
\end{center}

容器配置参见附录 \ref{codelist} \nameref{dockerfile}

\clearpage
\section{实验成果}

完整源文件, 参见附录 \ref{codelist} \nameref{csim-c}.

\section{实验过程}

\subsection{Part A: 工作原理}

采用组相连映射方案, Cache结构如\figref{cache-org} 所示. 

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    node distance = 0pt,
    every node/.style = {
        inner sep = 0pt,
        outer sep = 0pt
    },
    every matrix/.style = {
        inner sep = 0pt,
        outer sep = 0pt
    },
  ]{
    \matrix (cache) [
        anchor = north,
        row sep = 5pt,
        column sep = 5pt,
        nodes = {rect, minimum width=50pt},
        left delimiter = \{,
        above delimiter = \{
    ]{
        \node {}; & \node {}; & \node [draw=none]{......}; & \node {}; \\
        \node {}; & \node {}; & \node [draw=none]{......}; & \node {}; \\
        \node {}; & \node {}; & \node [draw=none]{......}; & \node {}; \\
        \node [draw=none]{......}; & \node [draw=none]{......}; & \node [draw=none]{......}; & \node [draw=none]{......}; \\
        \node {}; & \node (cache line){}; & \node [draw=none]{......}; & \node (last){}; \\
    };
    \node at (-28pt, -150pt)(Cache line)[
        draw, thick, 
        minimum height = 20pt,
        minimum width = 170pt
        ]{};
    \matrix [
        left = -60pt of Cache line,
        column sep = 5pt,
        nodes = {rect, minimum height=15pt}
    ]{
        \node (valid bit)[minimum width=15pt]{v}; & \node [minimum width=30pt]{tag}; \\
    };
    \matrix (cache block)[
        right = -100pt of Cache line,
        column sep = -0.8pt,
        nodes = {rect, minimum height=15pt, minimum width=15pt},
        below delimiter = \}
    ]{
        \node {}; & \node {}; & \node {}; & \node [minimum width=30pt]{......}; & \node {}; \\
    };
    \matrix (address)[
        right = 40pt of cache,
        column sep = -0.8pt,
        nodes = {rect},
    ]{
        \node (tag)[minimum width=30pt, label=above:$t$ bits]{tag}; & \node (set index)[minimum width=60pt, label=above:$s$ bits]{set index}; & \node (block offset)[minimum width=70pt, label=above:$b$ bits]{block offset}; \\
    };
    \node [left=16pt of cache]{$S=2^s$ sets};
    \node [above=16pt of cache]{$E=2^e$ lines per set};
    \node [below=12pt of cache block]{$B=2^b$ bytes per block};
    \node [below=14pt of valid bit]{valid bit};
    \draw (-53pt,-123pt) to (-103pt,-140pt);
    \draw (-3pt,-123pt) to (47pt,-140pt);
    \draw[trace] (-96pt,-160pt) to (-96pt,-170pt);
    \draw[trace] (set index) |- (last);
    \draw[trace] (block offset) |- (cache block);
  }
  \end{tikzpicture}
  \caption{Cache的组成结构}\label{cache-org}
\end{figure}

Cache空间被分为$2^s$个组(set)，每个组含有$E$个行(line), 称作$E$路组相连. cache line由一个有效位(valid bit)，标签(tag)以及$2^b$个字的数据块(block)组成. 

在Cache的硬件实现中, CPU每次访问内存, 内存地址被划分为tag, set index, block offset三部分. 在set index对应的组中, 逐个比较有效cache line的tag与地址中的tag, 若匹配则Cache命中, 根据block offset访问数据; 若未命中, 按照某种策略替换cache line内容.

通常采用LRU替换策略. 为每个cache line增设一个计数值, 当一个cache line被访问时, 其计数值归零, 其余的有效cache line计数值加一. 每次Cache未命中而Cache已满时, 优先替换计数值最大的cache line.

\subsection{Part A: 程序流程}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}{
    \node (start)[startstop]{Start \texttt{csim.c}};
    \node (input)[io=3cm, left=3cm of start]{Input $s$, $E$, $b$, etc. as args};
    \node (parse)[process,below=of input]{Parse args};
    \node (init)[process,below=of parse]{Allocate memory for cache};
    \node (read)[process,below=of init]{Read an operation from trace file};
    \node (access)[process,right=of read]{Parse the operation and access the cache};
    \node (eof)[decision,below=of access]{End of trace file?};
    \node (deinit)[process,below=of eof]{Deallocate memory for cache};
    \node (output)[io=3cm,below=of deinit]{Output number of hits and misses};
    \node (stop)[startstop, left=3cm of output]{End \texttt{csim.c}};
    \draw[trace] (start) -- (input);
    \draw[trace] (input) -- (parse);
    \draw[trace] (parse) -- (init);
    \draw[trace] (init) -- (read);
    \draw[trace] (read) -- (access);
    \draw[trace] (access) -- (eof);
    \draw[trace] (eof) -- (deinit) node[pos=0.5,fill=white,inner sep=0]{Yes};
    \draw[trace] (eof) -| (read) node[pos=0.25,fill=white,inner sep=0]{No};
    \draw[trace] (deinit) -- (output);
    \draw[trace] (output) -- (stop);
    }
  \end{tikzpicture}
  \caption{Cache模拟程序的流程图}
\end{figure}
\subsection{Part A: 处理命令行参数}
\subsection{Part A: 分配内存空间}
\subsection{Part A: 模拟Cache访问}
\subsection{Part B: 第一次尝试}
\subsection[Part B: 针对32 x 32情形优化]{Part B: 针对$32 \times 32$情形优化}
\subsection[Part B: 针对64 x 64情形优化]{Part B: 针对$64 \times 64$情形优化}
\subsection[Part B: 针对61 x 67情形优化]{Part B: 针对$61 \times 67$情形优化}

\clearpage
\section{总结}

完成Cache Lab, 主要有以下收获:
\begin{itemize}
    \item 深入理解了内存访问的时空局部性, Cache的原理和意义;
    \item 掌握了Cache的组成结构, 与主存的映射方式;
    \item 掌握了组相连映射的思想, 能够定量分析映射过程;
    \item 掌握了LRU替换策略的思想, 能够自行通过软件实现;
    \item 体会了Cache对程序性能的影响, 明白了代码优化的重要性;
    \item 学会了矩阵转置算法中, 针对Cache进行优化的几种途径;
    \item 学会了使用 \verb|getopt| 库函数解析命令行参数;
\end{itemize}
本实验的所有材料已上传至GitHub:

\url{https://github.com/HasiNed/Computer-System}

\setupappendix

\clearpage
\section{代码清单}\label{codelist}

\subsection{\texttt{csim.c}}\label{csim-c}
\includecode{c}{../cachelab-handout/csim.c}

\subsection{\texttt{Dockerfile}}\label{dockerfile}
\includecode{dockerfile}{Dockerfile}